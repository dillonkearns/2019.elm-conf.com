-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.InputObject exposing (AuthenticateInput, AuthenticateInputOptionalFields, AuthenticateInputRequiredFields, ProposalPatch, ProposalPatchOptionalFields, RegisterInput, RegisterInputOptionalFields, RegisterInputRequiredFields, UpdateProposalByNodeIdInput, UpdateProposalByNodeIdInputOptionalFields, UpdateProposalByNodeIdInputRequiredFields, UpdateProposalInput, UpdateProposalInputOptionalFields, UpdateProposalInputRequiredFields, UpdateUserByNodeIdInput, UpdateUserByNodeIdInputOptionalFields, UpdateUserByNodeIdInputRequiredFields, UpdateUserInput, UpdateUserInputOptionalFields, UpdateUserInputRequiredFields, UserCondition, UserConditionOptionalFields, UserPatch, UserPatchOptionalFields, buildAuthenticateInput, buildProposalPatch, buildRegisterInput, buildUpdateProposalByNodeIdInput, buildUpdateProposalInput, buildUpdateUserByNodeIdInput, buildUpdateUserInput, buildUserCondition, buildUserPatch, encodeAuthenticateInput, encodeProposalPatch, encodeRegisterInput, encodeUpdateProposalByNodeIdInput, encodeUpdateProposalInput, encodeUpdateUserByNodeIdInput, encodeUpdateUserInput, encodeUserCondition, encodeUserPatch)

import Api.Interface
import Api.Object
import Api.Scalar
import Api.ScalarCodecs
import Api.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildAuthenticateInput : AuthenticateInputRequiredFields -> (AuthenticateInputOptionalFields -> AuthenticateInputOptionalFields) -> AuthenticateInput
buildAuthenticateInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, email = required.email, password = required.password }


type alias AuthenticateInputRequiredFields =
    { email : String
    , password : String
    }


type alias AuthenticateInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the AuthenticateInput input object.
-}
type alias AuthenticateInput =
    { clientMutationId : OptionalArgument String
    , email : String
    , password : String
    }


{-| Encode a AuthenticateInput into a value that can be used as an argument.
-}
encodeAuthenticateInput : AuthenticateInput -> Value
encodeAuthenticateInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "email", Encode.string input.email |> Just ), ( "password", Encode.string input.password |> Just ) ]


buildProposalPatch : (ProposalPatchOptionalFields -> ProposalPatchOptionalFields) -> ProposalPatch
buildProposalPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, authorId = Absent, title = Absent, abstract = Absent, pitch = Absent, outline = Absent, feedback = Absent, createdAt = Absent, updatedAt = Absent }
    in
    { id = optionals.id, authorId = optionals.authorId, title = optionals.title, abstract = optionals.abstract, pitch = optionals.pitch, outline = optionals.outline, feedback = optionals.feedback, createdAt = optionals.createdAt, updatedAt = optionals.updatedAt }


type alias ProposalPatchOptionalFields =
    { id : OptionalArgument Int
    , authorId : OptionalArgument Int
    , title : OptionalArgument String
    , abstract : OptionalArgument String
    , pitch : OptionalArgument String
    , outline : OptionalArgument String
    , feedback : OptionalArgument String
    , createdAt : OptionalArgument Api.ScalarCodecs.Datetime
    , updatedAt : OptionalArgument Api.ScalarCodecs.Datetime
    }


{-| Type for the ProposalPatch input object.
-}
type alias ProposalPatch =
    { id : OptionalArgument Int
    , authorId : OptionalArgument Int
    , title : OptionalArgument String
    , abstract : OptionalArgument String
    , pitch : OptionalArgument String
    , outline : OptionalArgument String
    , feedback : OptionalArgument String
    , createdAt : OptionalArgument Api.ScalarCodecs.Datetime
    , updatedAt : OptionalArgument Api.ScalarCodecs.Datetime
    }


{-| Encode a ProposalPatch into a value that can be used as an argument.
-}
encodeProposalPatch : ProposalPatch -> Value
encodeProposalPatch input =
    Encode.maybeObject
        [ ( "id", Encode.int |> Encode.optional input.id ), ( "authorId", Encode.int |> Encode.optional input.authorId ), ( "title", Encode.string |> Encode.optional input.title ), ( "abstract", Encode.string |> Encode.optional input.abstract ), ( "pitch", Encode.string |> Encode.optional input.pitch ), ( "outline", Encode.string |> Encode.optional input.outline ), ( "feedback", Encode.string |> Encode.optional input.feedback ), ( "createdAt", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDatetime) |> Encode.optional input.createdAt ), ( "updatedAt", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecDatetime) |> Encode.optional input.updatedAt ) ]


buildRegisterInput : RegisterInputRequiredFields -> (RegisterInputOptionalFields -> RegisterInputOptionalFields) -> RegisterInput
buildRegisterInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, name = required.name, email = required.email, password = required.password }


type alias RegisterInputRequiredFields =
    { name : String
    , email : String
    , password : String
    }


type alias RegisterInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the RegisterInput input object.
-}
type alias RegisterInput =
    { clientMutationId : OptionalArgument String
    , name : String
    , email : String
    , password : String
    }


{-| Encode a RegisterInput into a value that can be used as an argument.
-}
encodeRegisterInput : RegisterInput -> Value
encodeRegisterInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "name", Encode.string input.name |> Just ), ( "email", Encode.string input.email |> Just ), ( "password", Encode.string input.password |> Just ) ]


buildUpdateProposalByNodeIdInput : UpdateProposalByNodeIdInputRequiredFields -> (UpdateProposalByNodeIdInputOptionalFields -> UpdateProposalByNodeIdInputOptionalFields) -> UpdateProposalByNodeIdInput
buildUpdateProposalByNodeIdInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, nodeId = required.nodeId, patch = required.patch }


type alias UpdateProposalByNodeIdInputRequiredFields =
    { nodeId : Api.ScalarCodecs.Id
    , patch : ProposalPatch
    }


type alias UpdateProposalByNodeIdInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the UpdateProposalByNodeIdInput input object.
-}
type alias UpdateProposalByNodeIdInput =
    { clientMutationId : OptionalArgument String
    , nodeId : Api.ScalarCodecs.Id
    , patch : ProposalPatch
    }


{-| Encode a UpdateProposalByNodeIdInput into a value that can be used as an argument.
-}
encodeUpdateProposalByNodeIdInput : UpdateProposalByNodeIdInput -> Value
encodeUpdateProposalByNodeIdInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "nodeId", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) input.nodeId |> Just ), ( "patch", encodeProposalPatch input.patch |> Just ) ]


buildUpdateProposalInput : UpdateProposalInputRequiredFields -> (UpdateProposalInputOptionalFields -> UpdateProposalInputOptionalFields) -> UpdateProposalInput
buildUpdateProposalInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, patch = required.patch, id = required.id }


type alias UpdateProposalInputRequiredFields =
    { patch : ProposalPatch
    , id : Int
    }


type alias UpdateProposalInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the UpdateProposalInput input object.
-}
type alias UpdateProposalInput =
    { clientMutationId : OptionalArgument String
    , patch : ProposalPatch
    , id : Int
    }


{-| Encode a UpdateProposalInput into a value that can be used as an argument.
-}
encodeUpdateProposalInput : UpdateProposalInput -> Value
encodeUpdateProposalInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "patch", encodeProposalPatch input.patch |> Just ), ( "id", Encode.int input.id |> Just ) ]


buildUpdateUserByNodeIdInput : UpdateUserByNodeIdInputRequiredFields -> (UpdateUserByNodeIdInputOptionalFields -> UpdateUserByNodeIdInputOptionalFields) -> UpdateUserByNodeIdInput
buildUpdateUserByNodeIdInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, nodeId = required.nodeId, patch = required.patch }


type alias UpdateUserByNodeIdInputRequiredFields =
    { nodeId : Api.ScalarCodecs.Id
    , patch : UserPatch
    }


type alias UpdateUserByNodeIdInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the UpdateUserByNodeIdInput input object.
-}
type alias UpdateUserByNodeIdInput =
    { clientMutationId : OptionalArgument String
    , nodeId : Api.ScalarCodecs.Id
    , patch : UserPatch
    }


{-| Encode a UpdateUserByNodeIdInput into a value that can be used as an argument.
-}
encodeUpdateUserByNodeIdInput : UpdateUserByNodeIdInput -> Value
encodeUpdateUserByNodeIdInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "nodeId", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) input.nodeId |> Just ), ( "patch", encodeUserPatch input.patch |> Just ) ]


buildUpdateUserInput : UpdateUserInputRequiredFields -> (UpdateUserInputOptionalFields -> UpdateUserInputOptionalFields) -> UpdateUserInput
buildUpdateUserInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, patch = required.patch, id = required.id }


type alias UpdateUserInputRequiredFields =
    { patch : UserPatch
    , id : Int
    }


type alias UpdateUserInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the UpdateUserInput input object.
-}
type alias UpdateUserInput =
    { clientMutationId : OptionalArgument String
    , patch : UserPatch
    , id : Int
    }


{-| Encode a UpdateUserInput into a value that can be used as an argument.
-}
encodeUpdateUserInput : UpdateUserInput -> Value
encodeUpdateUserInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "patch", encodeUserPatch input.patch |> Just ), ( "id", Encode.int input.id |> Just ) ]


buildUserCondition : (UserConditionOptionalFields -> UserConditionOptionalFields) -> UserCondition
buildUserCondition fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias UserConditionOptionalFields =
    { id : OptionalArgument Int }


{-| Type for the UserCondition input object.
-}
type alias UserCondition =
    { id : OptionalArgument Int }


{-| Encode a UserCondition into a value that can be used as an argument.
-}
encodeUserCondition : UserCondition -> Value
encodeUserCondition input =
    Encode.maybeObject
        [ ( "id", Encode.int |> Encode.optional input.id ) ]


buildUserPatch : (UserPatchOptionalFields -> UserPatchOptionalFields) -> UserPatch
buildUserPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { name = Absent, firstTimeSpeaker = Absent, speakerUnderrepresented = Absent }
    in
    { name = optionals.name, firstTimeSpeaker = optionals.firstTimeSpeaker, speakerUnderrepresented = optionals.speakerUnderrepresented }


type alias UserPatchOptionalFields =
    { name : OptionalArgument String
    , firstTimeSpeaker : OptionalArgument Bool
    , speakerUnderrepresented : OptionalArgument Bool
    }


{-| Type for the UserPatch input object.
-}
type alias UserPatch =
    { name : OptionalArgument String
    , firstTimeSpeaker : OptionalArgument Bool
    , speakerUnderrepresented : OptionalArgument Bool
    }


{-| Encode a UserPatch into a value that can be used as an argument.
-}
encodeUserPatch : UserPatch -> Value
encodeUserPatch input =
    Encode.maybeObject
        [ ( "name", Encode.string |> Encode.optional input.name ), ( "firstTimeSpeaker", Encode.bool |> Encode.optional input.firstTimeSpeaker ), ( "speakerUnderrepresented", Encode.bool |> Encode.optional input.speakerUnderrepresented ) ]
