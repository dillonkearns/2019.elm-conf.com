-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.InputObject exposing (AuthenticateInput, AuthenticateInputOptionalFields, AuthenticateInputRequiredFields, CreateProposalInput, CreateProposalInputOptionalFields, CreateProposalInputRequiredFields, ProposalCondition, ProposalConditionOptionalFields, ProposalInput, ProposalInputRequiredFields, ProposalPatch, ProposalPatchOptionalFields, RegisterInput, RegisterInputOptionalFields, RegisterInputRequiredFields, UpdateProposalByNodeIdInput, UpdateProposalByNodeIdInputOptionalFields, UpdateProposalByNodeIdInputRequiredFields, UpdateProposalInput, UpdateProposalInputOptionalFields, UpdateProposalInputRequiredFields, UpdateUserByNodeIdInput, UpdateUserByNodeIdInputOptionalFields, UpdateUserByNodeIdInputRequiredFields, UpdateUserInput, UpdateUserInputOptionalFields, UpdateUserInputRequiredFields, UserCondition, UserConditionOptionalFields, UserPatch, UserPatchOptionalFields, buildAuthenticateInput, buildCreateProposalInput, buildProposalCondition, buildProposalInput, buildProposalPatch, buildRegisterInput, buildUpdateProposalByNodeIdInput, buildUpdateProposalInput, buildUpdateUserByNodeIdInput, buildUpdateUserInput, buildUserCondition, buildUserPatch, encodeAuthenticateInput, encodeCreateProposalInput, encodeProposalCondition, encodeProposalInput, encodeProposalPatch, encodeRegisterInput, encodeUpdateProposalByNodeIdInput, encodeUpdateProposalInput, encodeUpdateUserByNodeIdInput, encodeUpdateUserInput, encodeUserCondition, encodeUserPatch)

import Api.Interface
import Api.Object
import Api.Scalar
import Api.ScalarCodecs
import Api.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildAuthenticateInput : AuthenticateInputRequiredFields -> (AuthenticateInputOptionalFields -> AuthenticateInputOptionalFields) -> AuthenticateInput
buildAuthenticateInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, email = required.email, password = required.password }


type alias AuthenticateInputRequiredFields =
    { email : String
    , password : String
    }


type alias AuthenticateInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the AuthenticateInput input object.
-}
type alias AuthenticateInput =
    { clientMutationId : OptionalArgument String
    , email : String
    , password : String
    }


{-| Encode a AuthenticateInput into a value that can be used as an argument.
-}
encodeAuthenticateInput : AuthenticateInput -> Value
encodeAuthenticateInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "email", Encode.string input.email |> Just ), ( "password", Encode.string input.password |> Just ) ]


buildCreateProposalInput : CreateProposalInputRequiredFields -> (CreateProposalInputOptionalFields -> CreateProposalInputOptionalFields) -> CreateProposalInput
buildCreateProposalInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, proposal = required.proposal }


type alias CreateProposalInputRequiredFields =
    { proposal : ProposalInput }


type alias CreateProposalInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the CreateProposalInput input object.
-}
type alias CreateProposalInput =
    { clientMutationId : OptionalArgument String
    , proposal : ProposalInput
    }


{-| Encode a CreateProposalInput into a value that can be used as an argument.
-}
encodeCreateProposalInput : CreateProposalInput -> Value
encodeCreateProposalInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "proposal", encodeProposalInput input.proposal |> Just ) ]


buildProposalCondition : (ProposalConditionOptionalFields -> ProposalConditionOptionalFields) -> ProposalCondition
buildProposalCondition fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, authorId = Absent }
    in
    { id = optionals.id, authorId = optionals.authorId }


type alias ProposalConditionOptionalFields =
    { id : OptionalArgument Int
    , authorId : OptionalArgument Int
    }


{-| Type for the ProposalCondition input object.
-}
type alias ProposalCondition =
    { id : OptionalArgument Int
    , authorId : OptionalArgument Int
    }


{-| Encode a ProposalCondition into a value that can be used as an argument.
-}
encodeProposalCondition : ProposalCondition -> Value
encodeProposalCondition input =
    Encode.maybeObject
        [ ( "id", Encode.int |> Encode.optional input.id ), ( "authorId", Encode.int |> Encode.optional input.authorId ) ]


buildProposalInput : ProposalInputRequiredFields -> ProposalInput
buildProposalInput required =
    { authorId = required.authorId, title = required.title, abstract = required.abstract, pitch = required.pitch, outline = required.outline, feedback = required.feedback }


type alias ProposalInputRequiredFields =
    { authorId : Int
    , title : String
    , abstract : String
    , pitch : String
    , outline : String
    , feedback : String
    }


{-| Type for the ProposalInput input object.
-}
type alias ProposalInput =
    { authorId : Int
    , title : String
    , abstract : String
    , pitch : String
    , outline : String
    , feedback : String
    }


{-| Encode a ProposalInput into a value that can be used as an argument.
-}
encodeProposalInput : ProposalInput -> Value
encodeProposalInput input =
    Encode.maybeObject
        [ ( "authorId", Encode.int input.authorId |> Just ), ( "title", Encode.string input.title |> Just ), ( "abstract", Encode.string input.abstract |> Just ), ( "pitch", Encode.string input.pitch |> Just ), ( "outline", Encode.string input.outline |> Just ), ( "feedback", Encode.string input.feedback |> Just ) ]


buildProposalPatch : (ProposalPatchOptionalFields -> ProposalPatchOptionalFields) -> ProposalPatch
buildProposalPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { title = Absent, abstract = Absent, pitch = Absent, outline = Absent, feedback = Absent }
    in
    { title = optionals.title, abstract = optionals.abstract, pitch = optionals.pitch, outline = optionals.outline, feedback = optionals.feedback }


type alias ProposalPatchOptionalFields =
    { title : OptionalArgument String
    , abstract : OptionalArgument String
    , pitch : OptionalArgument String
    , outline : OptionalArgument String
    , feedback : OptionalArgument String
    }


{-| Type for the ProposalPatch input object.
-}
type alias ProposalPatch =
    { title : OptionalArgument String
    , abstract : OptionalArgument String
    , pitch : OptionalArgument String
    , outline : OptionalArgument String
    , feedback : OptionalArgument String
    }


{-| Encode a ProposalPatch into a value that can be used as an argument.
-}
encodeProposalPatch : ProposalPatch -> Value
encodeProposalPatch input =
    Encode.maybeObject
        [ ( "title", Encode.string |> Encode.optional input.title ), ( "abstract", Encode.string |> Encode.optional input.abstract ), ( "pitch", Encode.string |> Encode.optional input.pitch ), ( "outline", Encode.string |> Encode.optional input.outline ), ( "feedback", Encode.string |> Encode.optional input.feedback ) ]


buildRegisterInput : RegisterInputRequiredFields -> (RegisterInputOptionalFields -> RegisterInputOptionalFields) -> RegisterInput
buildRegisterInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, name = required.name, email = required.email, password = required.password }


type alias RegisterInputRequiredFields =
    { name : String
    , email : String
    , password : String
    }


type alias RegisterInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the RegisterInput input object.
-}
type alias RegisterInput =
    { clientMutationId : OptionalArgument String
    , name : String
    , email : String
    , password : String
    }


{-| Encode a RegisterInput into a value that can be used as an argument.
-}
encodeRegisterInput : RegisterInput -> Value
encodeRegisterInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "name", Encode.string input.name |> Just ), ( "email", Encode.string input.email |> Just ), ( "password", Encode.string input.password |> Just ) ]


buildUpdateProposalByNodeIdInput : UpdateProposalByNodeIdInputRequiredFields -> (UpdateProposalByNodeIdInputOptionalFields -> UpdateProposalByNodeIdInputOptionalFields) -> UpdateProposalByNodeIdInput
buildUpdateProposalByNodeIdInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, nodeId = required.nodeId, patch = required.patch }


type alias UpdateProposalByNodeIdInputRequiredFields =
    { nodeId : Api.ScalarCodecs.Id
    , patch : ProposalPatch
    }


type alias UpdateProposalByNodeIdInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the UpdateProposalByNodeIdInput input object.
-}
type alias UpdateProposalByNodeIdInput =
    { clientMutationId : OptionalArgument String
    , nodeId : Api.ScalarCodecs.Id
    , patch : ProposalPatch
    }


{-| Encode a UpdateProposalByNodeIdInput into a value that can be used as an argument.
-}
encodeUpdateProposalByNodeIdInput : UpdateProposalByNodeIdInput -> Value
encodeUpdateProposalByNodeIdInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "nodeId", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) input.nodeId |> Just ), ( "patch", encodeProposalPatch input.patch |> Just ) ]


buildUpdateProposalInput : UpdateProposalInputRequiredFields -> (UpdateProposalInputOptionalFields -> UpdateProposalInputOptionalFields) -> UpdateProposalInput
buildUpdateProposalInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, patch = required.patch, id = required.id }


type alias UpdateProposalInputRequiredFields =
    { patch : ProposalPatch
    , id : Int
    }


type alias UpdateProposalInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the UpdateProposalInput input object.
-}
type alias UpdateProposalInput =
    { clientMutationId : OptionalArgument String
    , patch : ProposalPatch
    , id : Int
    }


{-| Encode a UpdateProposalInput into a value that can be used as an argument.
-}
encodeUpdateProposalInput : UpdateProposalInput -> Value
encodeUpdateProposalInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "patch", encodeProposalPatch input.patch |> Just ), ( "id", Encode.int input.id |> Just ) ]


buildUpdateUserByNodeIdInput : UpdateUserByNodeIdInputRequiredFields -> (UpdateUserByNodeIdInputOptionalFields -> UpdateUserByNodeIdInputOptionalFields) -> UpdateUserByNodeIdInput
buildUpdateUserByNodeIdInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, nodeId = required.nodeId, patch = required.patch }


type alias UpdateUserByNodeIdInputRequiredFields =
    { nodeId : Api.ScalarCodecs.Id
    , patch : UserPatch
    }


type alias UpdateUserByNodeIdInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the UpdateUserByNodeIdInput input object.
-}
type alias UpdateUserByNodeIdInput =
    { clientMutationId : OptionalArgument String
    , nodeId : Api.ScalarCodecs.Id
    , patch : UserPatch
    }


{-| Encode a UpdateUserByNodeIdInput into a value that can be used as an argument.
-}
encodeUpdateUserByNodeIdInput : UpdateUserByNodeIdInput -> Value
encodeUpdateUserByNodeIdInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "nodeId", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecId) input.nodeId |> Just ), ( "patch", encodeUserPatch input.patch |> Just ) ]


buildUpdateUserInput : UpdateUserInputRequiredFields -> (UpdateUserInputOptionalFields -> UpdateUserInputOptionalFields) -> UpdateUserInput
buildUpdateUserInput required fillOptionals =
    let
        optionals =
            fillOptionals
                { clientMutationId = Absent }
    in
    { clientMutationId = optionals.clientMutationId, patch = required.patch, id = required.id }


type alias UpdateUserInputRequiredFields =
    { patch : UserPatch
    , id : Int
    }


type alias UpdateUserInputOptionalFields =
    { clientMutationId : OptionalArgument String }


{-| Type for the UpdateUserInput input object.
-}
type alias UpdateUserInput =
    { clientMutationId : OptionalArgument String
    , patch : UserPatch
    , id : Int
    }


{-| Encode a UpdateUserInput into a value that can be used as an argument.
-}
encodeUpdateUserInput : UpdateUserInput -> Value
encodeUpdateUserInput input =
    Encode.maybeObject
        [ ( "clientMutationId", Encode.string |> Encode.optional input.clientMutationId ), ( "patch", encodeUserPatch input.patch |> Just ), ( "id", Encode.int input.id |> Just ) ]


buildUserCondition : (UserConditionOptionalFields -> UserConditionOptionalFields) -> UserCondition
buildUserCondition fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias UserConditionOptionalFields =
    { id : OptionalArgument Int }


{-| Type for the UserCondition input object.
-}
type alias UserCondition =
    { id : OptionalArgument Int }


{-| Encode a UserCondition into a value that can be used as an argument.
-}
encodeUserCondition : UserCondition -> Value
encodeUserCondition input =
    Encode.maybeObject
        [ ( "id", Encode.int |> Encode.optional input.id ) ]


buildUserPatch : (UserPatchOptionalFields -> UserPatchOptionalFields) -> UserPatch
buildUserPatch fillOptionals =
    let
        optionals =
            fillOptionals
                { name = Absent, firstTimeSpeaker = Absent, speakerUnderrepresented = Absent }
    in
    { name = optionals.name, firstTimeSpeaker = optionals.firstTimeSpeaker, speakerUnderrepresented = optionals.speakerUnderrepresented }


type alias UserPatchOptionalFields =
    { name : OptionalArgument String
    , firstTimeSpeaker : OptionalArgument Bool
    , speakerUnderrepresented : OptionalArgument Bool
    }


{-| Type for the UserPatch input object.
-}
type alias UserPatch =
    { name : OptionalArgument String
    , firstTimeSpeaker : OptionalArgument Bool
    , speakerUnderrepresented : OptionalArgument Bool
    }


{-| Encode a UserPatch into a value that can be used as an argument.
-}
encodeUserPatch : UserPatch -> Value
encodeUserPatch input =
    Encode.maybeObject
        [ ( "name", Encode.string |> Encode.optional input.name ), ( "firstTimeSpeaker", Encode.bool |> Encode.optional input.firstTimeSpeaker ), ( "speakerUnderrepresented", Encode.bool |> Encode.optional input.speakerUnderrepresented ) ]
